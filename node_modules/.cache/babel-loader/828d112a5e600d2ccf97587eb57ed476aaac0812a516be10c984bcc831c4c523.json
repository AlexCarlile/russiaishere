{"ast":null,"code":"var _jsxFileName = \"/Users/alexselyukov/Documents/russiaishere/src/store/AuthContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';\nimport { jwtDecode } from 'jwt-decode';\nimport Cookies from 'js-cookie';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AuthContext = /*#__PURE__*/createContext(undefined);\nexport const AuthProvider = ({\n  children\n}) => {\n  _s();\n  // Читаем роль из localStorage при инициализации\n  const [userRole, setUserRole] = useState(() => localStorage.getItem('Role'));\n  const [authorized, setAuthorized] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Функция загрузки роли пользователя с API\n  const fetchUserRole = useCallback(async token => {\n    try {\n      const response = await fetch(\"http://127.0.0.1:5000/user\", {\n        method: 'GET',\n        headers: {\n          Authorization: `Bearer ${token}`\n        }\n      });\n      if (response.ok) {\n        var _userData$role;\n        const userData = await response.json();\n        setUserRole(userData.role || null);\n        localStorage.setItem('Role', ((_userData$role = userData.role) === null || _userData$role === void 0 ? void 0 : _userData$role.toString()) || '');\n      } else {\n        console.warn('Failed to fetch user data');\n        setUserRole(null);\n        localStorage.removeItem('Role');\n      }\n    } catch (err) {\n      console.error('Error fetching user data:', err);\n      setUserRole(null);\n      localStorage.removeItem('Role');\n    }\n  }, []);\n\n  // Проверка токена и состояния авторизации (без запроса на сервер)\n  const checkAuthorization = useCallback(() => {\n    const token = Cookies.get('token');\n    if (!token) {\n      setAuthorized(false);\n      setUserRole(null);\n      localStorage.removeItem('Role');\n      setIsLoading(false);\n      return;\n    }\n    try {\n      const decoded = jwtDecode(token);\n      const currentTime = Date.now() / 1000;\n      if (decoded.exp && decoded.exp > currentTime) {\n        setAuthorized(true);\n      } else {\n        Cookies.remove('token');\n        setAuthorized(false);\n        setUserRole(null);\n        localStorage.removeItem('Role');\n      }\n    } catch (error) {\n      console.error('Invalid token', error);\n      Cookies.remove('token');\n      setAuthorized(false);\n      setUserRole(null);\n      localStorage.removeItem('Role');\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  // При монтировании и изменении authorized грузим роль, если её нет и токен есть\n  useEffect(() => {\n    checkAuthorization();\n  }, [checkAuthorization]);\n  useEffect(() => {\n    const token = Cookies.get('token');\n\n    // Если авторизован, есть токен и роли нет в state — загружаем её\n    if (authorized && token && !userRole) {\n      fetchUserRole(token);\n    }\n  }, [authorized, userRole, fetchUserRole]);\n\n  // toggleAuthorized можно оставить, если нужна ручная смена состояния авторизации\n  const toggleAuthorized = param => {\n    setAuthorized(param);\n  };\n  const contextValue = useMemo(() => ({\n    authorized,\n    isLoading,\n    userRole,\n    toggleAuthorized,\n    checkAuthorization\n  }), [authorized, isLoading, userRole, toggleAuthorized, checkAuthorization]);\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 117,\n    columnNumber: 5\n  }, this);\n};\n_s(AuthProvider, \"2/V+S3GXENrYfplJWnRb1qxcipo=\");\n_c = AuthProvider;\nexport const useAuth = () => {\n  _s2();\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n_s2(useAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useCallback","useMemo","jwtDecode","Cookies","jsxDEV","_jsxDEV","AuthContext","undefined","AuthProvider","children","_s","userRole","setUserRole","localStorage","getItem","authorized","setAuthorized","isLoading","setIsLoading","fetchUserRole","token","response","fetch","method","headers","Authorization","ok","_userData$role","userData","json","role","setItem","toString","console","warn","removeItem","err","error","checkAuthorization","get","decoded","currentTime","Date","now","exp","remove","toggleAuthorized","param","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useAuth","_s2","context","Error","$RefreshReg$"],"sources":["/Users/alexselyukov/Documents/russiaishere/src/store/AuthContext.tsx"],"sourcesContent":["import React, {\n  createContext,\n  useContext,\n  useState,\n  useEffect,\n  useCallback,\n  useMemo\n} from 'react';\nimport { jwtDecode } from 'jwt-decode';\nimport Cookies from 'js-cookie';\n\ntype AuthContextType = {\n  authorized: boolean;\n  isLoading: boolean;\n  userRole: string | null;\n  toggleAuthorized: (param: boolean) => void;\n  checkAuthorization: () => void;\n};\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  // Читаем роль из localStorage при инициализации\n  const [userRole, setUserRole] = useState<string | null>(() => localStorage.getItem('Role'));\n  const [authorized, setAuthorized] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n\n  // Функция загрузки роли пользователя с API\n  const fetchUserRole = useCallback(async (token: string) => {\n    try {\n      const response = await fetch(\"http://127.0.0.1:5000/user\", {\n        method: 'GET',\n        headers: {\n          Authorization: `Bearer ${token}`,\n        },\n      });\n\n      if (response.ok) {\n        const userData = await response.json();\n        setUserRole(userData.role || null);\n        localStorage.setItem('Role', userData.role?.toString() || '');\n      } else {\n        console.warn('Failed to fetch user data');\n        setUserRole(null);\n        localStorage.removeItem('Role');\n      }\n    } catch (err) {\n      console.error('Error fetching user data:', err);\n      setUserRole(null);\n      localStorage.removeItem('Role');\n    }\n  }, []);\n\n  // Проверка токена и состояния авторизации (без запроса на сервер)\n  const checkAuthorization = useCallback(() => {\n    const token = Cookies.get('token');\n\n    if (!token) {\n      setAuthorized(false);\n      setUserRole(null);\n      localStorage.removeItem('Role');\n      setIsLoading(false);\n      return;\n    }\n\n    try {\n      const decoded: any = jwtDecode(token);\n      const currentTime = Date.now() / 1000;\n\n      if (decoded.exp && decoded.exp > currentTime) {\n        setAuthorized(true);\n      } else {\n        Cookies.remove('token');\n        setAuthorized(false);\n        setUserRole(null);\n        localStorage.removeItem('Role');\n      }\n    } catch (error) {\n      console.error('Invalid token', error);\n      Cookies.remove('token');\n      setAuthorized(false);\n      setUserRole(null);\n      localStorage.removeItem('Role');\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  // При монтировании и изменении authorized грузим роль, если её нет и токен есть\n  useEffect(() => {\n    checkAuthorization();\n  }, [checkAuthorization]);\n\n  useEffect(() => {\n    const token = Cookies.get('token');\n\n    // Если авторизован, есть токен и роли нет в state — загружаем её\n    if (authorized && token && !userRole) {\n      fetchUserRole(token);\n    }\n  }, [authorized, userRole, fetchUserRole]);\n\n  // toggleAuthorized можно оставить, если нужна ручная смена состояния авторизации\n  const toggleAuthorized = (param: boolean) => {\n    setAuthorized(param);\n  };\n\n  const contextValue = useMemo(() => ({\n    authorized,\n    isLoading,\n    userRole,\n    toggleAuthorized,\n    checkAuthorization,\n  }), [authorized, isLoading, userRole, toggleAuthorized, checkAuthorization]);\n\n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}